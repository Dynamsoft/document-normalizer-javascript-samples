<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description"
    content="Quickly detect document boundaries from a live camera stream and crop the document out before normalizing it further through perspective correction, deskewing, and more.">
  <meta name="keywords" content="camera based quadrilateral detection and normalization">
  <title>Detect the boundary of a document and normalize it</title>
  <script
    src="https://npm.scannerproxy.com/cdn/@dynamsoft/dynamsoft-core@3.0.10-dev-20230811163138/dist/core.js"></script>
  <script src="https://npm.scannerproxy.com/cdn/@dynamsoft/utility@0.20230814110732.0/dist/utility.js"></script>
  <script src="https://npm.scannerproxy.com/cdn/@dynamsoft/cvrjs@0.20230815103342.0/dist/cvr.js"></script>
  <script
    src="https://npm.scannerproxy.com/cdn/@dynamsoft/dynamsoft-camera-enhancer@4.0.0-dev-20230811163231/dist/dce.js"></script>
</head>

<body>
  <h1 style="font-size: 1.5em;">Detect the boundary of a document and normalize it</h1>
  <button id="start-detecting" onclick="startDetecting()">Start Detecting</button>
  <button id="restart-detecting" onclick="restartDetecting()" style="display: none;">Restart Detecting</button>
  <button id="confirm-quad-for-normalization">Confirm the Boundary</button>
  <button id="normalize-with-confirmed-quad" disabled>Normalize</button><br>
  <input type="checkbox" style="vertical-align: middle;" id="ipt-checkbox"><label style="vertical-align: middle;"
    for="ipt-checkbox">Normalize Automatically</label>
  <div id="div-ui-container" style="margin-top: 10px;height: 500px;"></div>
  <div id="div-image-container" style="display:none; width: 100vw; height: 70vh"></div>
  <div id="normalized-result"></div>
  <script>
    let quads = [];
    let view = null;
    let cameraEnhancer = null;
    let router = null;
    let items;
    let image;
    let layer;
    let imageEditorView;
    let promiseCVRReady;
    let frameCount = 0;

    const btnStart = document.querySelector("#start-detecting");
    const btnRestart = document.querySelector("#restart-detecting");
    const cameraViewContainer = document.querySelector("#div-ui-container");
    const normalizedImageContainer = document.querySelector("#normalized-result");
    const btnEdit = document.querySelector("#confirm-quad-for-normalization");
    const btnNormalize = document.querySelector("#normalize-with-confirmed-quad");
    const imageEditorViewContainer = document.querySelector("#div-image-container");
    const iptCheckbox = document.querySelector("input");

    /** LICENSE ALERT - README
     * To use the library, you need to first specify a license key using the API "license" as shown below.
    */
    Dynamsoft.License.LicenseManager.initLicense("DLS2eyJvcmdhbml6YXRpb25JRCI6IjIwMDAwMSJ9");
    /**
     * You can visit https://www.dynamsoft.com/customer/license/trialLicense?utm_source=github&architecture=dcv&product=ddn&package=js to get your own trial license good for 30 days.
     * For more information, see https://dynamsoft.com/document-normalizer/docs/web/programming/javascript/user-guide/?ver=2.0.10&utm_source=github#configure-the-license or contact support@dynamsoft.com.
     * LICENSE ALERT - THE END
    */

    Dynamsoft.CVR.CaptureVisionRouter.preloadModule(["DDN"]);

    iptCheckbox.addEventListener("change", () => {
      btnEdit.style.display = iptCheckbox.checked ? "none" : "inline";
      btnNormalize.style.display = iptCheckbox.checked ? "none" : "inline";
    })

    async function startDetecting() {
      try {
        await (promiseCVRReady = promiseCVRReady || (async () => {
          view = await Dynamsoft.DCE.CameraView.createInstance();
          cameraEnhancer = await Dynamsoft.DCE.CameraEnhancer.createInstance(view);
          imageEditorView = await Dynamsoft.DCE.ImageEditorView.createInstance(imageEditorViewContainer);
          /* Create an image editing layer view */
          layer = imageEditorView.createDrawingLayer();
          router = await Dynamsoft.CVR.CaptureVisionRouter.createInstance();
          /* Set the result type to be returned, because we need to normalize the original image later, so here we set the return result type to quadrilateral and original image data */
          let newSettings = await router.getSimplifiedSettings("detect-document-boundaries");
          newSettings.capturedResultItemTypes = Dynamsoft.Core.EnumCapturedResultItemType.CRIT_DETECTED_QUAD | Dynamsoft.Core.EnumCapturedResultItemType.CRIT_ORIGINAL_IMAGE;
          await router.updateSettings("detect-document-boundaries", newSettings);
          cameraViewContainer.append(view.getUIElement());
          router.setInput(cameraEnhancer);

          const resultReceiver = new Dynamsoft.CVR.CapturedResultReceiver();

          resultReceiver.onCapturedResultReceived = async (result) => {
            console.log(result);
            image = result.items.filter(item => item.type === 1)[0].imageData;
            if (!iptCheckbox.checked) {
              items = result.items;
            } else {
              if (result.items.length <= 1) {
                frameCount = 0;
                return;
              }
              frameCount++;
              /* If automatic normalize is enabled, the optimal quadrilateral will be automatically normalized after the result is detected for 15 consecutive frames */
              if (frameCount === 80) {
                frameCount = 0;
                normalizedImageContainer.innerHTML = "";
                /* Set the location of the item that needs to be normalized to roi */
                let ss = await router.getSimplifiedSettings("normalize-document");
                ss.roiMeasuredInPercentage = 0;
                ss.roi.points = result.items[1].location.points;
                await router.updateSettings("normalize-document", ss);
                /* Capture executes the normalize task */
                let normalizeResult = await router.capture(result.items.filter(item => item.type === 1)[0].imageData, "normalize-document");
                normalizedImageContainer.append(normalizeResult.items[0].toCanvas());
                cameraViewContainer.style.display = "none";
                btnStart.style.display = "none";
                btnRestart.style.display = "inline";
                await router.stopCapturing();
              }
            }
          }

          /* Specifiy the result receiver */
          router.addResultReceiver(resultReceiver);

          btnEdit.addEventListener("click", async () => {
            /* Stop the previous detecting task since we assume we have found a good boundary */
            router.stopCapturing();
            /* Hide the cameraView and show the imageEditorView */
            cameraViewContainer.style.display = "none";
            imageEditorViewContainer.style.display = "block";
            /* Draw the image in the imageEditorView first */
            imageEditorView.setOriginalImage(image);
            quads = [];
            /* Draw the quad */
            for (let i = 0; i < items.length; i++) {
              if (items[i].type === Dynamsoft.Core.EnumCapturedResultItemType.CRIT_ORIGINAL_IMAGE) continue;
              const points = items[i].location.points;
              const quad = new Dynamsoft.DCE.DrawingItem.QuadDrawingItem({ points });
              quads.push(quad);
              layer.addDrawingItems(quads);
            }
            btnNormalize.disabled = false;
            btnEdit.disabled = true;
          })

          btnNormalize.addEventListener("click", async () => {
            /* Hide the imageEditorView */
            imageEditorViewContainer.style.display = "none";
            /* Remove the old normalized image if any */
            normalizedImageContainer.innerHTML = "";
            /* Get the selected quadrilateral */
            let seletedItems = imageEditorView.getSelectedDrawingItems();
            if (seletedItems.length) {
              let quad = seletedItems[0].getQuad();
              /* Set roi */
              let newSettings = await router.getSimplifiedSettings("normalize-document");
              newSettings.roiMeasuredInPercentage = 0;
              newSettings.roi.points = quad.points;
              await router.updateSettings("normalize-document", newSettings);
              /* Capture executes the normalize task */
              let normalizeResult = await router.capture(image, "normalize-document");
              normalizedImageContainer.append(normalizeResult.items[0].toCanvas());
              layer.clearDrawingItems();
            }
            btnNormalize.disabled = true;
            btnEdit.disabled = false;
            /* show video view */
            cameraViewContainer.style.display = "block";
            view.getUIElement().style.display = "";
            await router.startCapturing("detect-document-boundaries");
          })

          /* Start streaming the video */
          await cameraEnhancer.open();
          /* Use the built-in template "detect-document-boundaries" to start a boundary detecting task */
          await router.startCapturing("detect-document-boundaries");
        })())
      } catch (ex) {
        let errMsg;
        if (ex.message.includes("network connection error")) {
          errMsg = "Failed to connect to Dynamsoft License Server: network connection error. Check your Internet connection or contact Dynamsoft Support (support@dynamsoft.com) to acquire an offline license.";
        } else {
          errMsg = ex.message || ex;
        }
        console.error(errMsg);
        alert(errMsg);
      }
    };

    async function restartDetecting() {
      normalizedImageContainer.innerHTML = "";
      cameraViewContainer.style.display = "block";
      btnStart.style.display = "inline";
      btnRestart.style.display = "none";
      await router.startCapturing("detect-document-boundaries");
    }
  </script>
</body>

</html>